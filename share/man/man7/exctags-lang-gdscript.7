.\" Man page generated from reStructuredText.
.
.TH CTAGS-LANG-GDSCRIPT 7 "" "6.1.0" "Universal Ctags"
.SH NAME
ctags-lang-gdscript \- Random notes about tagging GDScript source code with Universal Ctags
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH SYNOPSIS
.nf
\fBctags\fP ... \-\-languages=+GDScript ...
\fBctags\fP ... \-\-language\-force=GDScript ...
\fBctags\fP ... \-\-map\-GDScript=+.gd ...
.fi
.sp
.SH DESCRIPTION
.sp
This man page gathers random notes about tagging GDScript source code
with Universal Ctags.
.SH STORING ANNOTATIONS
.sp
Like the Python parser storing decorations to \fBdecorations\fP field,
the GDScript parser stores annotations
starting from \fI@\fP to the language specific field, \fBannotations\fP\&.
Though the field is enabled explicitly in following examples, the
field is enabled by default.
.sp
"input.gd"
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@export
var s = "Hello"

@master
func f(msg):
        print(msg)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
"output.tags"
with "\-\-options=NONE \-\-sort=no \-\-fields\-GDScript=+{annotations} \-o \- input.gd"
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
s       input.gd        /^var s = "Hello"$/;"   v       annotations:export
f       input.gd        /^func f(msg):$/;"      m       annotations:master
.ft P
.fi
.UNINDENT
.UNINDENT
.SH EXTRACTING FUNC
.sp
A language object defined with \fIfunc\fP keyword is tagged with \fBmethod\fP kind.
Like annotations, the parser stores keywords modifying \fIfunc\fP like \fIstatic\fP to
the \fBannotations\fP field.
.sp
"input.gd"
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
func f(x):
        return x

static func f_s(x):
        reutrn x

remote func f_r(x):
        return x
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
"output.tags"
with "\-\-options=NONE \-\-sort=no \-\-fields=+K \-\-fields\-GDScript=+{annotations} \-o \- input.gd"
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
f       input.gd        /^func f(x):$/;"        method
f_s     input.gd        /^static func f_s(x):$/;"       method  annotations:static
f_r     input.gd        /^remote func f_r(x):$/;"       method  annotations:remote
.ft P
.fi
.UNINDENT
.UNINDENT
.SH TAGGING IMPLICITLY DEFINED CLASSES
.sp
"A file is a class!" in GDScript.  A class is implicitly
defined. Functions, variables, constants, and signals are parts of the
class though the class is unnamed by default.
.sp
If the language specific extra, \fBimplicitClass\fP, is enabled, the
parser makes a anonymous tag for the class. The parser fills the scope
fields of the tags for all language objects defined in the file with
the anonymous tag.
.sp
Let\(aqs see an example demonstrating the effect of the extra.
.sp
Turning off the extra:
.sp
"input.gd"
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
func f(x):
        return x
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
"output.tags"
with "\-\-options=NONE \-\-fields=+KZ \-\-extras\-GDScript=\-{implicitClass} \-o \- input.gd"
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
f       input.gd        /^func f(x):$/;"        method
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Turning on the extra:
.sp
"input.gd"
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
func g(x):
        return x
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
"output.tags"
with "\-\-options=NONE \-\-fields=+KZ \-\-extras\-GDScript=+{implicitClass} \-o \- input.gd"
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
anon_class_84011bee0100 input.gd        /^func g(x):$/;"        class
g       input.gd        /^func g(x):$/;"        method  scope:class:anon_class_84011bee0100
.ft P
.fi
.UNINDENT
.UNINDENT
.SH TAGGING THE NAME SPECIFIED WITH CLASS_NAME
.sp
\fIclass_name\fP is a keyword for giving a name to the implicitly defined
class.  If \fBimplicitClass\fP is turned off, the parser just extract
the name coming after the keyword with \fBclass\fP kind. If
\fBimplicitClass\fP is turned on, the parser converts the anonymous tag
to a non\-anonymous tag with the specified name.  When converting,
the parser also updates scope fields of the other tags in the file.
.sp
Turning off the extra:
.sp
"input.gd"
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class_name c

func f(x):
        return x
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
"output.tags"
with "\-\-options=NONE \-\-fields=+KZ \-\-extras\-GDScript=\-{implicitClass} \-o \- input.gd"
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
c       input.gd        /^class_name c$/;"      class
f       input.gd        /^func f(x):$/;"        method
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Turning on the extra:
.sp
"input.gd"
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class_name C
func g(x):
        return x
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
"output.tags"
with "\-\-options=NONE \-\-fields=+KZ \-\-extras\-GDScript=+{implicitClass} \-o \- input.gd"
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
C       input.gd        /^class_name C$/;"      class
g       input.gd        /^func g(x):$/;"        method  scope:class:C
.ft P
.fi
.UNINDENT
.UNINDENT
.SH FILLING INHERITS FIELD
.sp
\fIextends\fP keyword specifies the super class for the implicitly defined class.
If \fIimplicitClass\fP extra is turned on, the parser fills \fBinherits\fP field
of the tag for the implicitly defined class with the name of super class.
.sp
"input.gd"
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
extends B
class_name C
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
"output.tags"
with "\-\-options=NONE \-\-fields=+Ki \-\-extras\-GDScript=+{implicitClass} \-o \- input.gd"
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
C       input.gd        /^class_name C$/;"      class   inherits:B
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
When \fI\-\-extras=+r\fP is given, the parser extracts the class specified with the
\fIextends\fP keyword as a reference tag of \fBclass\fP kind with \fBextended\fP role.
.sp
"input.gd"
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
extends B
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
"output.tags"
with "\-\-options=NONE \-\-fields=+rEK \-\-extras=+r \-o \- input.gd"
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
B       input.gd        /^extends B$/;" class   roles:extended  extras:reference
.ft P
.fi
.UNINDENT
.UNINDENT
.SH SEE ALSO
.sp
ctags(1)
.\" Generated by docutils manpage writer.
.
